## Linux网络编程第一阶段

> 202105 ~ 202108 [【网络编程】C++之Linux网络编程系列_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1Ub411J7vH?from=search&seid=16454255848580949812&spm_id_from=333.337.0.0&vd_source=347ccd5e0d1f5374dbfbdd800d438163)

#### 1 网络中的地址

- **IPv4地址4B**
- **IPv6地址16B**
- **mac地址6B**

```powershell
> ipconfig /all	# 查看本机网络配置
```

![image-20220717184258925](https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20220717184258925.png)



#### 2 网络通信基本原则

- **对等通讯** -- 通讯双方在**相同层**上进行通讯，且遵循**相同协议**
- **封装** -- **发送方按照协议封装上层数据**，使接收方对等层可以识别
- **解封装** -- **接收方按照协议解封装**，提取数据并向上层交付

- 封装：数据通过各层时，**封装**上不同层规定的**首、尾部**，使对方的**对等层**可以识别。

<img src="https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20210714084531319.png" alt="image-20210714084531319" style="zoom:50%;" />



#### 3 ping程序详解 

- **应用层程序**，用于判断ip是否可达

- 基于DNS、ICMP、ARP的**实现过程**

  - 通过DNS协议，将baidu.com转化为ip地址

  - 发送ICMP报文

  - 通过ARP协议，将ip地址转化为mac地址

  - 收到ICMP响应，并据此判断ip是否可达

<img src="https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20210714092304662.png" alt="image-20210714092304662" style="zoom: 50%;" />

![image-20220717190901801](https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20220717190901801.png)



#### 4 socket 套接字 

- socket是**用户进程与内核协议栈的编程接口**
- socket类型
  - SOCK_STREM -- 流式套接字，TCP用
  - SOCK_DGRAM -- 数据报格式套接字，UDP用
  - SOCK_RAW -- 原始套接字

![image-20220717192028317](https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20220717192028317.png)



**sockaddr_in** 结构体（**IPV4套接字地址结构**）

```c
struct sockaddr_in{
    sa_family_t     sin_family;   //地址族（Address Family），也就是地址类型
    uint16_t        sin_port;     //16位(转化时要用htons)的端口号
    struct in_addr  sin_addr;     //32位IP地址
    char            sin_zero[8];  //不使用，一般用0填充
};
```

-  in_addr结构体本质为四字节unsigned int

-  人类可识别的IP地址为字符串形式（例如"127.0.0.1"），所以需要 inet_addr() 函数完成从字符串到unsigned int的转换。                

**sockaddr** 结构体（**通用地址结构**）

```c
struct sockaddr{
    sa_family_t sin_family;	//地址家族
    char sa_data[14];		//由sin_family决定具体形式
}
```

IPV4套接字地址结构**转通用地址结构**

```c
(sockaddr*)(&sockaddr_in)
```



#### 5 粘包问题详解

粘包指**发送端一次发送数据与接收方一次接收数据不一致的现象**

- 发送方一次发送的数据被接收方多次读出
- 发送方多次发送的数据被接收方一次读出



**粘包是TCP独有的问题**，因为TCP是基于字节流的协议，不维护消息边界

- 受Naggle算法影响，发送方多次write可能被合并成一个包发送
- 收链路层MTU影响，发送方一次write可能被拆成多个包发送
- 接收方的接收行为.....

UDP是基于数据报的协议，有消息边界，不存在粘包问题



粘包问题的**解决方式**

- 定长包，每个包的长度为固定值
- 固定长度头部 + dlen字段
- 更复杂的应用层协议



#### 6 TCP客户服务器模型

<img src="https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20210716233356993.png" alt="image-20210716233356993" style="zoom: 50%;" />

**服务器端**

```c
//创建套接字
int serv_sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);

//创建sockaddr_in结构体变量
struct sockaddr_in serv_addr;
memset(&serv_addr, 0, sizeof(serv_addr));  //每个字节都用0填充
serv_addr.sin_family = AF_INET;  //使用IPv4地址
serv_addr.sin_addr.s_addr = inet_addr("127.0.0.1");  //具体的IP地址
serv_addr.sin_port = htons(1234);  //端口

//将套接字和IP、端口绑定（注意将sockaddr_in强制转化为sockaddr格式，两者都是16字节，部分细节不同）
bind(serv_sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr));

//将主动套接字（客户端用）转化为被动套接字（服务器用）
listen(serv_sock, SOMAXCONN);  

//接收客户端请求
struct sockaddr_in clnt_addr;
socklen_t clnt_addr_size = sizeof(clnt_addr);
int clnt_sock = accept(serv_sock, (struct sockaddr *)&clnt_addr, &clnt_addr_size);
	//在此处阻塞，直至有客户端发起连接;
	//这里创建了新的套接字，该套接字用于真正和客户端通讯
	//clnt_addr中填充了客户端的地址信息
```

**客户端**

```c
//创建套接字    SOCK_STREAM表示面向连接的套接字（走TCP协议）
int sock = socket(AF_INET, SOCK_STREAM, 0);
//向服务器（特定的IP和端口）发起请求
struct sockaddr_in serv_addr;
memset(&serv_addr, 0, sizeof(serv_addr));           //每个字节都用0填充
serv_addr.sin_family = AF_INET;                     //使用IPv4地址
serv_addr.sin_addr.s_addr = inet_addr("127.0.0.1"); //具体的IP地址
serv_addr.sin_port = htons(1234);                   //端口
connect(sock, (struct sockaddr *)&serv_addr, sizeof(serv_addr));
```



#### 7 TCP的11种状态

<img src="https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20210719211622183.png" alt="image-20210719211622183" style="zoom:50%;" />



#### 8 标准IO函数

**标准IO(stdio)**

- ANSI C建立的一个标准I/O模型
  - ANSI C -- 美国国家标准协会（ANSI）对C语言发布的标准
- 本体是标准函数包和stdio.h头文件中的定义
- **内部有缓存机制**
- **可移植性强**（开发环境中有标准I/O库就可使用）
- **标准IO以C风格字符串为单位进行数据交换**



**FILE* 流指针**：

- stdin、stdout、stderr均为流指针
- fopen()打开文件，返回流指针
- socketfd也可以转化位流指针



**fopen() 打开流**

- **filename**：打开的文件名称（c字符串形式）

- **mode**：打开方式

- 成功打开返回一个 FILE* 指针

- 错误时，返回 NULL，并设置errno

|        mode        |   "r"    |      "w"       |   "a"    |     "r+"     |      "w+"      |   "a+"   |
| :----------------: | :------: | :------------: | :------: | :----------: | :------------: | :------: |
|        含义        | 只读打开 | 创建只写空文件 | 只写追加 | 可读可写打开 | 创建读写空文件 | 读写追加 |
| 是否要求文件已存在 |    是    |       /        |    /     |      是      |       /        |    /     |

```c++
FILE *fopen(const char *filename, const char *mode);	// 函数原型

FILE* fp;
fp = fopen("data.md", "w+");
```



**fgets() 从流中读取1行或n字节**

- **str** ：缓存地址

- **n** ：读取的最大字符数（包含C风格字符串默认的结尾空字符）

  - 当读取 (n-1) 个字符时即停止
  - **第n个字符自动补`\0`**

- **stream**：待读取的流

- 读取成功时返回与str相同的指针

- **读取失败或读到EOF返回NULL**

  ```c++
  char *fgets(char *str, int n, FILE *stream);	// 函数原型
  
  if( fgets (str, 60, fp)!=NULL ){
  	puts(str);   
  }
  ```

  

**fputs() 写入流**

- **str**：要写入的C风格字符串
- **stream**：被写入字符串的流

```c++
int fputs(const char *str, FILE *stream);	// 函数原型

fputs("kakak\n", stderr);	// 向标准错误输出
fputs("kakak\n", stdout);	// 向标准输入输出
```



**feof() 判断流是否到达结束位置**

- 如果到达stream到达EOF位置，*则*返回0**

  ```c++
  int feof(FILE *stream);	// 函数原型
  
  if(feof(fp) == 0) {		// 已经读到文件末尾
  	break;
  }
  ```



## TCP/IP网络编程

> 20211121 ~ 20220122

### 第1章 理解网络编程和套接字

#### 1.2  基于Linux的文件操作

**Linux认为socket是文件的一种**，因此在网络数据传输的过程中，可以**使用文件I/O函数接口**

- 文件描述符编号**按照顺序依次分配**，0、1、2、3、4、5......

- Linux默认打开0、1、2文件描述符

  <img src="https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20211030110007084.png" alt="image-20211030110007084"  />



**文件操作**

- 打开文件描述符


![image-20211030110653732](https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20211030110653732.png)

![image-20211030110747122](https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20211030110747122.png)

- 关闭文件描述符


![image-20211030110834006](https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20211030110834006.png)

- 写操作


![image-20211030110943325](https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20211030110943325.png)

**长度类型size_t**

ssize_t、size_t都是**元数据类型**，在 `sys/types.h` 头文件中声明

- 用于适配 16、32、64位的操作系统（修改typedef即可）

- 以 `_t` 结尾，以便**区分**

  ```c++
  typedef unsigned int size_t;
  typedef signed size_t ssize_t;	// 多加的 s 表示 signed
  ```

- `int32_t`可以保证在**任意操作系统**下都占用**32bit**



### 第2章 套接字类型与协议设置

#### 2.1套接字协议及其数据传输特性

**协议**(Protocol) -- **分布式的对等层实体在信息交换过程中遵守的规范集合**

**协议族**(Protocol Family) -- 相互关联的协议集合

![image-20220728214800593](https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20220728214800593.png)



**套接字类型**

- **SOCK_STREAM -- 可靠的、按序传递的，基于字节流的、面向连接的套接字**，类比流水线运输
  
  - 传输过程中数据不会丢失（**可靠**）
  - 按序传输数据（**有序**）
  - 传输的数据不存在数据边界（**无休止的流**）
    - 一次发多次收、多次发一次收都有可能（**粘包**）
  - 套接字连接一一对应（**面向连接**，双方同时在线）
  
- **SOCK_DGRAM -- 不可靠的、不按序传递的、以数据高速传输为目的、面向消息的套接字**，类比快递服务

  - 数据可能丢失或损毁（**不可靠**）
  - 发送顺序与接受顺序无关（**不按序**，可能先发后到）
  - 存在数据边界
  - 限制单次传输的数据量
  - 非面向连接（**不要求对方也在线**）

  - *DGRAM -> datagram（数据报）*



### 第3章 地址族与数据序列

#### 3.1 分配给套接字的IP地址与端口号

**IP(Internet Protocol )** -- 网络层协议

IP地址 -- IP协议中规定的地址号，分为两类：

![image-20211030162837769](https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20211030162837769.png)

**IPv4地址 = 网络号 + 主机号**

- 网络号标识所在子网

- 主机号标志主机在子网中的编号

- **网络号 = IP地址 & 子网掩码**

  <img src="https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20211030235638754.png" alt="image-20211030235638754" style="zoom:50%;" />





**端口号** -- 主机使用端口号区分套接字，**将网络层提供的端到端的服务，强化为进程到进程之间的服务**

- 端口号为16位（2B），范围0 ~ 65535
- 0 ~ 1023为**知名端口**，一般分配给特定的应用程序
  - 21 -- FTP
  - 22 -- SSH
  - 23 -- Telnet
  - 53 -- DNS
  - 80 -- Http



#### 3.2 地址信息的表示

**IPv4地址结构体 sockaddr_in**，用于**存储地址信息**

- **sa_family_t -> unsigned short int**
- **in_addr_t** -> **uint32_t**

<img src="https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20220728220729826.png" alt="image-20220728220729826" style="zoom:80%;" />



**通用地址结构体sockaddr**

- bind、accept、connect函数**输入为sockaddr类型**
- 可由sockaddr_in转化得到，`2 + 2 + 4 + 8 = 2 + 14`

<img src="https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20220728220818597.png" alt="image-20220728220818597" style="zoom:80%;" />





#### 3.3 网络字节序与地址变换

**字节序(Byte Order)**

![image-20211031003159058](https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20211031003159058.png)

- **网络字节序**（Network Byte Order）为大端序
  - **网络中的数据一律按大端序传输**
  - 对于小端序的CPU需要先进行字节转化，再发送到网路上
- **主机字节序**（Host Byte Order）
  - 由主机CPU决定
  - **Intel、AMD系列CPU均使用小端字节序**



**字节序转换**

- 只有向sockaddr_in结构体变量赋值时需要字节转换
- 普通数据传输有自动转化机制

![image-20211121233850135](https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20211121233850135.png)

- 以htons为例

  - h：host
  - to：to
  - n：network
  - s：short





#### 3.4 网络地址的初始化与分配

**点分十进制地址转u32**

![image-20211121235539057](https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20211121235539057.png)



**u32转点分十进制地址**

![image-20211121235944157](https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20211121235944157.png)



**网络地址初始化流程示例**

![image-20211122000701893](https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20211122000701893.png)



**INADDR_ANY** -- 自行获取服务器端所有网卡的IP

![image-20211122000949066](https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20211122000949066.png)



**bind -- 建立套接字和地址的绑定关系**，即将地址指定给套接字

![image-20211122001650900](https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20211122001650900.png)

![image-20211122001703638](https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20211122001703638.png)



### 第4章 基于TCP的服务器端 / 客户端（1)

#### 4.1 TCP与UDP

**TCP/IP协议栈**

- **链路层**：在相邻node间完成RDT

- **网络层**：路由选择及转发

- **传输层**：控制数据传输过程

- **应用层**：提供套接字编程接口
  - 将程序员从底层数据传输过程中解放出来
  - 网络编程的主要任务是设计、实现应用层协议

<img src="https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20211122223814655.png" alt="image-20211122223814655" style="zoom: 80%;" />



#### 4.2 实现基于TCP的服务器端 / 客户端

**TCP服务器流程**

![image-20211122225231026](https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20211122225231026.png)

**listen() -- 主动套接字转被动套接字**

- 服务器进入等待连接请求阶段
- **使listenfd成为一个专门负责接待的门卫**

![image-20211122225626490](https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20211122225626490.png)



**accept()** -- 正式受理客户端连接请求

- **从内核中已完成连接队列取出1个连接**
- 如果内核连接队列为空，**则阻塞**至有客户端主动发起连接

![image-20211122230620852](https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20211122230620852.png)





**TCP客户端流程**

![image-20211122230831818](https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20211122230831818.png)

**connect()** -- 向服务器主动发起连接

- **会阻塞**，直至服务器端接受连接

![image-20211122231100399](https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20211122231100399.png)



**客户端的IP:Port  -- 在调用connect时，由操作系统内核分配主机IP和随机端口**



**基于TCP的服务器端/客户端函数调用关系**

- **客户端可以在服务器端bind listen后调用connect**

- 如果在服务器端 listen 前调用connect，会发生错误，返回-1（实测如此）
- **connect在accept前**：客户端进入阻塞，服务端将连接加入已完成连接队列
- **accept在connect前**：客户端直接返回，服务端获取连接

![image-20211122231552678](https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20211122231552678.png)



### 第5章 基于TCP的服务器端 / 客户端（2)

#### 5.2 TCP原理（包含三次握手&四次挥手）

**TCP 套接字中的I/O缓冲** -- 每个TCP套接字，单独拥有输入、输出缓存区

- 应用层write直接**向输出缓存区写数据**
- 应用层read直接**从输入缓冲区读数据**
- 缓存区在**创建套接字时自动生成**
  - 服务器：socket()和accept()
  - 客户端：socket()
- 调用close()后
  - **输出缓存区中的数据，由协议栈保证发送完毕**
  - **输入缓存区中的数据，立刻丢失**


![image-20211123000241902](https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20211123000241902.png)



**seq与ack** -- 以字节为单位的**对TCP字节流的编码**

- **seq(序列号)**
  - **发送方用序列号标识当前发送的数据所在的字节流编号**
  - seq=1000标识当前发送以字节流编号为1000开头的数据


- **ack(确认号)**
  - **接收方用确认号累积确认已经接收的字节流编号**
  - ack=1000标识已经收到编号<=999的字节流数据，希望下次接收offset=1000开头的数据


![image-20220728224654479](https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20220728224654479.png)



**TCP的三次握手**

- 握手时**双方需随机选择seq初始值**
- 握手时不传输数据，但消耗1个字节流编号

![image-20211123003034858](https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20211123003034858.png)



**超时重传机制**

- 发送方到达超时时间后，仍未收到ack确认
- 则认为数据丢失，触发重传



**TCP的四次挥手**

- 保障close()调用者，**将发送缓存区的所有数据发送完毕**，并释放双方套接字缓冲区等资源

  - **FIN**：主机 A 想断开连接


  - **ACK**：主机 B 表示收到断开请求，并做断开准备


  - **FIN**：主机 B 准备完毕，也发送断开请求


  - **ACK**：主机 A 收到 B 的 FIN，回复确认 

    ![image-20211127013639652](https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20211127013639652.png)



### 第6章 基于UDP的服务端 / 客户端

#### 6.1 理解UDP

**UDP传输过程类似于送信**

- 不需要知道对方是否在家
- 每次都需要填上目的地地址
- UDP套接字就像邮筒（需要有自己的地址）



**UDP传输速率高于TCP的原因**

- **没有收发数据前后进行的握手、挥手过程**
  - 在应答式的短链接中，会频繁出现此过程

- **没有RDT**



#### 6.2 基于UDP的服务器 \ 客户端（包含端口分配详解）

UDP 中的服务器、客户端没有连接，且**均只需要 1 个套接字**（只需要一个邮筒）

- UDP 1 个套接字就可以**向任意主机发送数据**、**从任意主机接收数据**
  - TCP 服务器需要 １+ n 个套接字：**1个监听套接字 + n个数据传输套接字**
  - TCP 客户端需要 1个数据传输套接字

- UDP每次发送数据前，都要给数据**打上目标地址**（类似于写信填地址）

![image-20211127165545552](https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20211127165545552.png)





**sendto()**

- **发送数据到指定邮箱**

- 需要指定对方地址（TCP不用）


![image-20220728232102241](https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20220728232102241.png)

  

**recvfrom()**

- 接收已**到达本UDP套接字的数据**
- 由于**UDP发送方不固定，该函数用from记录对端地址**

![image-20220728232141268](https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20220728232141268.png)



**UDP报文存在边界**

- 不考虑丢包时，**sendto()应与recvfrom()一一对应**

- **recvfrom()没有全部取出sendto()数据时，其余数据会被丢弃**
- UDP没有粘包问题



**UDP套接字地址分配(IP:Port)**⭐

- 服务器端**主动调用 bind() 绑定**

![image-20220728232838050](https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20220728232838050.png)

- 客户端**首次调用sendto()时，自动分配【本机IP】和【随机空闲端口】**



**TCP套接字地址分配(IP:Port)**⭐

- 服务器端
  - **监听套接字主动调用bind()手动绑定**
  - **数据传输套接字在accept()时自动分配**
    - IP与listenfd一致
    - Port随机分配空闲端口
- 客户端**调用connect()时，自动分配【本机IP】和【随机空闲端口】**



**UDP每次调用sendto()时的发送过程**

- 第一阶段：向UDP套接字注册目标IP、Port信息（完成后，UDP套接字处于**已连接状态**）
- 第二阶段：传输数据
- 第三阶段：删除UDP套接字中注册的目标IP、Port信息（完成后，UDP套接字处于**未连接状态**）
- 优点：可以**向多个目标地址发送信息**
- 缺点：向同一个目标多次发送信息时，**效率低下**
  - 解决方法，调用connect函数主动注册对端信息，使UDP套接字始终处于连接状态
  - 连接指注册有对端信息，不代表两端都在线（那是TCP干的事）
  - 如此一来，一个UDP只能向一个目标地址发送信息



### 第7章 优雅地断开套接字连接

#### 7.1 基于TCP的半关闭

**TCP套接字为全双工**，存在2条I/O流

![image-20220113215208546](https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20220113215208546.png)



**半关闭** -- 关闭双流其中的一个

- 只能接收无法发送
- 或只能发送而无法接收



**shutdown()**

![image-20220113220223509](https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20220113220223509.png)

- **howto = SHUT_RD：断开输入流**
  - **立刻丢弃输入缓存区中的数据**
  - 禁止调用read等输入函数
- **howto = SHUT_WR：断开输出流**
  - 禁止调用write等输出函数
  - **输出缓存区中的数据由协议栈保证发送完毕**
- howto = SHUT_RDWR：断开输入输出流
  - 行为 = SHUT_RD + SHUT_WR



**半关闭程序实例**

![image-20220113224257768](https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20220113224257768.png)

### 第8章 域名及网址系统

#### ８.1 域名系统

**域名系统(DNS Domain Name System)**

- 域名是**IP地址的字符串形式别名**
  - 如`www.baidu.com/`
  - 方便人类记忆
  - 通过DNS服务器，解析为IP地址
- **域名相对于IP地址不容易改变**，因为IP地址常常会发生变化
- DNS工作过程

<img src="https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20220113231255882.png" alt="image-20220113231255882" style="zoom: 80%;" />



**nslookup** -- 查看本机默认DNS服务器

![image-20220728234656043](https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20220728234656043.png)



#### 8.2 IP地址和域名之间的转换

**gethostbyname() -- 利用域名获取IP地址**

- **hostent结构体**中最重要的是**h_addr_list：域名对应的IP地址列表**

<img src="https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20220113232251563.png" alt="image-20220113232251563" style="zoom: 67%;" />

<img src="https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20220113232416538.png" alt="image-20220113232416538" style="zoom: 80%;" />

<img src="https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20220113232537701.png" alt="image-20220113232537701" style="zoom: 67%;" />



**gethostbyaddr() **

![image-20220113234229543](https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20220113234229543.png)



### 第9章 套接字的多种可选项

内核中的套接字有多种属性可以设置

**getsockopt() 获取套接字属性**

![image-20220728235450744](https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20220728235450744.png)





**setsockopt() 设置套接字属性**

![image-20220728235602939](https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20220728235602939.png)



#### 9.1 SO_SNDBUF SO_RCVBUF（I/O缓冲大小）

**缓存区大小属性 SO_SNDBUF、SO_RCVBUF**

![image-20220114213026927](https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20220114213026927.png)

![image-20220114213042588](https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20220114213042588.png)

![image-20220114215124143](https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20220114215124143.png)



#### 9.2 SO_REUSEADDR（允许重复bind同一端口）

**SO_REUSEADDR**(reuseaddr) -- **控制是否允许在time_wait状态下重新绑定前一端口**



**Time_wait状态**

- **主动断开TCP连接的一方**，会经历一段**处在time_wait状态的时间，以确保对方收到第四次挥手的ACK包**

  ![image-20220114220644883](https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20220114220644883.png)

- 如果没有对方收到第四次挥手的ACK包**，处在time_wait状态下主机A会重传ACK包**

![image-20220114220920338](https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20220114220920338.png)

**time_wait状态可能导致服务器无法立即重启**

- **服务器主动断开连接**
- 无发立即重启服务器，会发生**Binding Error**
- 因为服务器处于time_wait状态时，**无法重新绑定同一端口**
- **客户端可以立即重启，不会报错**
  - 因为客户端的端口是在connect时由内核自动选择空闲端口绑定的
  - 注意客户端也会经过time_wait状态



**SO_REUSEADDR设置为true**

- 使得**处在time_wait状态下的端口可以被重新绑定给套接字**

- 这样**服务器就可以立即重启**，继续工作

  ![image-20220114222249576](https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20220114222249576.png)



#### TCP_NODELAY（允许流水线发送）

**Nagle算法**

- 应用于TCP层，**防止数据包过多**而**导致网络过载**
- Nagle算法要求，**收到前一数据的ACK包后，才能再发送下一数据**

![image-20220114231220892](https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20220114231220892.png)

- 优点：等待ACK过程中，**输出缓存区积累的数据，可以一次性发送出去**，可以大大**减少数组包数量**。
- 缺点：**传输大文件时**等待ACK包的时间会**拖累传输速度**
- 所以是否开启Nagle算法，要**根据传输的数据特征决定**，Nagle算法**默认处于开启状态**



**TCP_NODELAY -- 控制Nagle算法的状态**

- 禁用Nagle算法

  ![image-20220114231850644](https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20220114231850644.png)



### 第10章 多进程服务器端

#### 10.1 进程概念及应用

**并发服务器端的实现方法**

- 多进程服务器
- 多线程服务器
- IO多路复用



**进程 Process**

- 进程是**占用内存空间，正在运行的程序**
- 应用程序运行起来会**启动1~n个进程**，运行一个应用程序至少需要启动一个进程
- **最大进程同时并发数 = CPU核数**，超过时会分时复用



**PID**：

- 进程ID：操作系统内核回**给每个进程分配的唯一ID**
- ID = 1的进程分配给系统使用
- **`ps au`** 指令可查看当前在Linux中运行的ID

![image-20220115161944815](https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20220115161944815.png)



**fork() 进程创建函数**

- **fork将创建调用进程的副本**，复制了相同的内存空间
- 此处的内存空间包括：常量区、全局区、静态区、堆、栈等一切，这使得父子进程间完全独立
- 两个进程**都将执行fork()之后的函数**
- 父子进程**通过PID区分**
  - 父进程fork()返回值为**子进程PID**
  - 子进程fork()**返回值为0**


![image-20220114234803464](https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20220114234803464.png)



#### 10.2 进程和僵尸进程

**子进程正常销毁的过程**

- 子进程终止自身的方式
  - **exit退出进程**
  - **main函数中return返回**
- 向exit中传递的参数和return的返回值**会传递给操作系统**
- **操作系统不会立刻销毁子进程，直到把这些值传递给产生该子进程的父进程**



**僵尸进程**

- **终止自身后**，**等待操作系统将返回值传递给父进程时的子进程**
- 正是**操作系统把子进程变成僵尸进程**
- **操作系统不会主动把值传递给父进程**，父进程需要**主动查询**（负责回收自己的孩子）
- 僵尸进程依赖于父进程，父进程销毁后，对应的子僵尸进程也会销毁



**销毁僵尸进程1 wait()函数**

- 父进程调用wait()后，**【阻塞等待】【任意子进程】终止**，**直到获取其返回值**

- 如果调用后没有子进程销毁自身，则**父进程会一直阻塞**

```c++
int staues;
wait(&status);
```

![image-20220115001233702](https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20220115001233702.png)



**销毁僵尸进程2 waitpid()函数**

- 父进程调用waitpid()后，**等待指定子进程终止**，**直到获取其返回值**


```c++
int status;
waitpid(-1, &status, WNOHANG);	// 查询任意终止的子进程，进程退出状态传递给status，WNOHANG表示非阻塞
```

![image-20220115094948729](https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20220115094948729.png)

#### 10.3 信号处理

**信号(Signal)：特定事件发生时由操作系统向进程发送的消息**

**信号处理(Signal Handling)**：进程接收到信号后，执行的自定义操作



**signal() 信号处理函数注册**

![image-20220115104046086](https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20220115104046086.png)

- **signo指定触发的信号类型**
  - **SIGALRM**：由alarm()函数触发，响了一次后如需重复触发，则要重新设定闹钟
  - **SIGINT**：控制台输入Ctrl+C触发
  - **SIGCHLD**：子进程终止时触发


![image-20220115111150340](https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20220115111150340.png)

- **func注册给指定信号的函数指针**

  - 会在信号触发时回调

  - 要求为**void(* func)(int)**类型的函数
    - 返回值类型为void
    - 有一个int型参数

- **返回值也是函数指针类型**

```c++
signal(SIGALRM, timeout);   // 注册SIGALRM信号处理函数
signal(SIGINT, keycontrol); // 注册SIGINT信号处理函数
```



**sigaction() signal()函数的上位替代**

![image-20220115155044823](https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20220115155044823.png)

![image-20220115155111406](https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20220115155111406.png)



**利用信号消除僵尸进程**

- **捕捉子进程结束时触发的SIGCLD信号并处理**，子进程不会变成僵尸进程

- `WIFEXITED`关键字，用于**判断子进程是否正常结束**（正常结束时`WIFEXITED(status`)返回非0值）

  ```c++
  void read_childproc(int sig)
  {
      int status;
      pid_t id = waitpid(-1, &status, WNOHANG); // 由于是子进程结束触发的信号处理函数，所以此处必能立即返回 >0 的子进程pid值
      if (WIFEXITED(status))
      {
          printf("Removed proc id: %d \n", id);             // 输出结束的子进程ID
          printf("Child send: %d \n", WEXITSTATUS(status)); // 输出子进程结束时的返回值
      }
  }
  
  struct sigaction act;
  act.sa_handler = read_childproc;
  sigemptyset(&act.sa_mask);
  act.sa_flags = 0;
  sigaction(SIGCLD, &act, 0); // 注册SIGCLD信号处理函数
  ```

  

#### 10.4 基于多进程的并发服务器

多进程并发服务器模型

- 父进程负责用accept**受理连接**
- 连接完成后，**交给子进程处理**

![image-20220115163914580](https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20220115163914580.png)

**fork()过程中的文件描述符**

- **套接字属于操作系统**，fork时子进程**复制的只是文件描述符**

- 复制了文件描述符后，有多个文件描述符对应一个套接字

  <img src="https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20220115165019786.png" alt="image-20220115165019786" style="zoom: 80%;" />

- 父、子进程需要**分别关闭文件描述符**

  - 例如子进程一开始就关闭了 serv_sock（因为子进程不管受理）
  - 父进程在连接后，立刻关闭了clnt_sock（因为父进程不管业务处理）

- 只有当套接字**对应的所有文件描述符都关闭时**，**操作系统才会销毁套接字**



#### 10.5 分割TCP的I/O程序

**分割IO即I/O各占用一个进程**

- 程序实现更简单（功能划得分细，单个进程承担的任务少）

- 可以提高频繁交换数据的程序的性能（升级为流水线）

![image-20220117211905722](https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20220117211905722.png)

![image-20220117211942492](https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20220117211942492.png)



### 第12章 I/O复用

#### 12.1 基于I/O复用的服务器端

- **复用**（Multiplexing）：在**1个通信频道**中**传递多种信号**的技术

  - 优点
    - 缩短连线长度
    - 减少纸杯个数

  ![image-20220118002048505](https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20220118002048505.png)

  - 通过**分时、分频**技术，可以用**一根线**传递多种信号



- **服务器I/O复用模型**：只需要**1个进程提供所有服务**（接收连接 + 处理连接）

<img src="https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20220118002340089.png" alt="image-20220118002340089" style="zoom: 80%;" />



#### 12.2 理解select函数并实现服务器端

**fd_set**

- **按位组织的文件描述符集合**

- 第i位代表fd==i的文件描述符

![image-20220118234926301](https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20220118234926301.png)

**配套宏接口**

- **FD_ZERO**(fd_set* fdset)：将fdset清0

- **FD_SET**(int fd, fd_set* fdset)：注册fd至fdset

- **FD_CLR**(int fd, fd_set* fdset)：将fd从fdset中清除

- **FD_ISSET**(int fd, fd_set* fdset)：判定fd是否在fdset中****被设置为**1**

  <img src="https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20220118235045496.png" alt="image-20220118235045496" style="zoom: 80%;" />



**select() IO复用**

<img src="https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20220118235509129.png" alt="image-20220118235509129" style="zoom:80%;" />

- **maxfd**：`max(已注册文件描述值) + 1`

  - 用于**表征文件描述符的检测范围**
  - select**在内核中要依次遍历[0, maxfd)**的文件描述符

- **readset**：关注的**读事件**文件描述符集合（如无，设置为NULL）

  - **TCP连接请求属于可读事件**（建立连接的过程中也要传递数据）

- **writeset**：关注的**写事件**文件描述符集合（如无，设置为NULL）

- **exceptset**：关注的**异常事件**文件描述符集合（如无，设置为NULL）

- **timeout**：**超时**设置，**防止永久阻塞**（如需永久阻塞，设置为NULL）

  - 循环调用时，timeout需要重设

  <img src="https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20220119000513333.png" alt="image-20220119000513333" style="zoom: 67%;" />

- **返回值**

  - -1：select发生错误
  - 0：select超时
  - 正整数：**发生事件的文件描述符总数**


```c++
int result = select(1, &temp_set, NULL, NULL, &timeout); // 只关注读事件，写事件和异常事件不管，则直接传NULL
```



**select结果查看**

- fd_set中**没有事件发生**的文件描述符位**置0**
- fd_set中**有事件发生**的文件描述符位**置1**
- 重复调用select时，fd_set需要**恢复初始状态**
  - `temp_set = read_set; // 恢复被select重置的替身`



### 第17章 优于select的epoll

#### 17.1epoll理解及应用

**select的瓶颈**

- select效率低下，无论如何优化，也无法同时接入上百个客户端

- **select返回时需要遍历[0, maxfd)的文件描述符**，以确认触发的事件
- **每次调用select时，都需要向内核传递set信息**（涉及用户态和内核态间的切换，开销极大）

```c++
for(int ii=0; ii<fd_max+1; ii++){		// 遍历[0, max_fd+1)
	if(FD_ISSET(ii, &read_sets) != 0){	// 确认当前文件描述符是否被触发
		// ···
    }
}

select(1, &temp_set, NULL, NULL, &timeout);	// 这里需要将temp_set中的关注的事件信息【传递给内核】
```



**epoll_event -- epoll事件结构体**

- 在epoll_ctl中，作为输入参数表示关注的事件

- 在epoll_wait中，作为输出参数表示已发生的事件集合


- **events可选项**
  - **EPOLLIN**：可读事件
  - **EPOLLOUT**：可写事件
  - **EPOLLET**：边沿触发

```c++
struct epoll_event{
    epoll_data_t data;	// 本质是int型的文件描述符
	__uint32_t events;	// fd对应的关注事件，如可读、可写事件等
}

typedef union epoll_data{
    // ...
    int fd;				// 文件描述符（data中实际使用的数据）
    // ...
}epoll_data_t;

// 创建实例化对象
epoll_event event;
event.data.fd = clnt_fd;

event.events = EPOLLIN;				// 可读事件
event.events = EPOLLOUT;			// 可写事件
event.events = EPOLLIN | EPOLLIN;	// 可读 + 可写事件
```



**epoll_create() -- 创建epoll句柄**

![image-20220119230424984](https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20220119230424984.png)

- **返回值为epoll句柄epfd**

  - **本质上是文件描述符**（深入贯彻linux一切皆文件的总纲领23333）
  - epfd的资源**由操作系统创建并管理**
  - 终止时，需要调用close(epfd)，**让操作系回收epoll资源**

- size值无用，直接忽略

  ```c++
  int epfd = epoll_create(0);
  ```

  

**epoll_ctl() -- 向epfd中增、删、改事件**

![image-20220119231025655](https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20220119231025655.png)

- **epfd**：epoll句柄
- **op**：操作类型，可用参数为：
  - **EPOLL_CTL_ADD**：注册fd对应事件
  - **EPOLL_CTL_DEL**：删除fd对应事件
  - **EPOLL_CTL_MOD**：修改fd对应事件
- **fd：需要纳入epfd监测的文件描述符**
- **event：监视对象关注的事件类型** 
  - 当op=EPOLL_CTL_DEL时，event需传入NULL

```c++
int epfd = epoll_create(0);

epoll_event event;
event.events = EPOLLIN;
event.data.fd = sockfd;
epoll_ctl(epfd, EPOLL_CTL_ADD, sockfd, &event);	// 将sockfd的读事件加入epfd关注

epoll_ctl(epfd, EPOLL_CTL_DEL, sockfd, NULL);	// 删除sockfd相关事件
```



**epoll_wait() -- 阻塞等待事件发生**

![image-20220119234014350](https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20220119234014350.png)

- **events是事件数组**，epoll返回时，将有发生的事件信息存入该数组

```c++
#define MAX_EVENT_NUMBER 10000 			// 最大事件数
epoll_event events[MAX_EVENT_NUMBER];	// 分配事件数组资源

int number = epoll_wait(epollfd, events, MAX_EVENT_NUMBER, -1); //等待epoll监控的文件描述符有事件发生
for (int i = 0; i < number; i++) {		// 循环处理所有就绪事件
	int sockfd = events[i].data.fd;		// 提取有事件发生的fd
    // 业务逻辑处理...
}
```



#### 17.2 条件触发和边缘触发

**epoll的触发方式**

- **LT条件触发(Level Tirgger)**
  - 只要缓存区**有数据就会一直触发**
  - epoll默认触发方式
  - select只支持条件触发
- **ET边缘触发(Edge Trigger)**
  - 缓存区收到数据时仅注册一次
  - 触发后即使没有读取全部数据，也不会再次触发



**fcntl() -- 修改文件描述符属性**

![image-20220120222437119](https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20220120222437119.png)

- cmd可选项

  - **F_GETFL**：获取fd属性
  - **F_SETFL**：修改fd属性

- **将sock_fd修改为非阻塞模式**

  ```c++
  int flag = fcntl(fd, F_GETFL, 0); 		// 获取fd属性（int型变量表示）
  fcntl(fd, F_SETFL, flag | O_NONBLOCK);	// 在原有属性基础上，【追加】非阻塞属性
  ```

  

**ET模式必须搭配非阻塞I\O**⭐

- 边沿触发模式下，**需要将缓存区数据一次性读完**

- **通过循环读取的方式实现**

- 此时阻塞IO在read、write时**可能会导致服务器长时间停顿**

  - 阻塞最后一次循环读取时，无数据即死阻塞

  ```c++
  while(1) {	// 循环读取，保证读完
      int str_len = read(ep_events[ii].data.fd, recv_buf, sizeof(recv_buf));
  	if (str_len == -1 && errno == EAGAIN) { // 缓存区数据已读完
          break;
      } else {
          write(ep_events[ii].data.fd, recv_buf, str_len); // echo
      }
  }
  ```

  

**ET模式的优势**

- **减少epoll_wait触发次数**，提高效率
  - 因为**epoll过程涉及用户态和内核态间的切换**，开销大
- 可以分离接收数据和处理数据的时间点



### 第18章 多线程服务器端的实现

#### 18.1 理解线程的概念

**多进程的缺点**

- 创建进程时，需要复制内存空间，开销大
- 进程间通讯困难，需要IPC技术（Inter Peocess Communication）
- 频繁的上下文切换（Context Switching），开销大



**线程 Thread**

- 一种**轻量级进程**，可以降低进程缺点的影响
- 线程的**创建和上下文切换更快**
- 线程间通讯**不需要IPC技术**



**进程和线程的本质**

- **获取并行的多条代码执行流**

- 进程：操作系统层面下的单独执行流单位
- 线程：进程层面下的单独执行流单位

![image-20220121000819621](https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20220121000819621.png)

**内存模型**

- **进程拥有独立的4G内存地址空间**

![image-20220121001206443](https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20220121001206443.png)

- 同一进程下的线程间**共享堆区、数据区数据**

  - **上下文切换时，不需要切换数据区、堆区的内存**

  - **线程间通讯/交换数据可以通过数据区、堆区实现**，无需借助操作系统

  - 线程的栈区是相互独立的

    ![image-20220121001527309](https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20220121001527309.png)



#### 18.2 线程的创建及运行

**POSIX标准（Portable Operating System Interface For Computer Environment**

- 为提高UNIX系列操作系统间移植而制定的**API规范**

- **Linux采用POSIX线程标准**



**pthread_create() -- 创建线程**

![image-20220121003622396](https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20220121003622396.png)

- **start_routine 函数指针**

  - 返回值为void* 类型

  - 有1个void* 类型参数

- 编译时需加`-lpthread`选项，**链接线程库**


```c++
pthread_create(&t_id, NULL, thread_main, (void *)&thread_param); // 创建thread_main线程
g++ 24_thread1.cc -lpthread -o 24_thread1	// 编译指令
```

![image-20220121014816757](https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20220121014816757.png)



**pthread_join() -- 阻塞等待指定线程结束**

![image-20220729010438414](https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20220729010438414.png)

- **阻塞等待thread结束**，避免子线程业务未执行完毕，主线程已退出

- status用于接收子进程返回值


```c++
void *msg;                 	// void*类型指针，用于接收进程返回的数据
pthread_join(t_id, &msg)	// 等待子进程返回
```

![image-20220121021022730](https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20220121021022730.png)



**临界区(Critical Section)函数**：

- 多个线程同时调用同一个函数，该函数内部代码被同时执行，据此，函数分为

- **线程安全函数**：在临界区执行不会引发问题
- **非线程安全函数**：在临界区执行会引发问题



**工作线程(Worker)模型**

- **子线程负责工作**，处理业务逻辑
- 主线程只需返回结果

<img src="https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20220121022228362.png" alt="image-20220121022228362" style="zoom: 80%;" />





#### 18.4 线程同步

**互斥量mutex(Mutual Exclusion)**

- 用锁定临界区资源的方式解决同步问题
- 操作临界区资源前，需先申请拿到互斥量



**互斥量接口函数**	

- **pthread_mutex_init()**：创建锁
- **pthread_mutex_lock()**：访问前上锁
- **pthread_mutex_unlock()**：访问后释放锁
- **pthread_mutex_destroy()**：销毁锁

<img src="https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20220729011228863.png" alt="image-20220729011228863" style="zoom:80%;" />

```c++
pthread_mutex_init(&mutex, NULL); // 创建锁，无特殊属性设置需求

// ...
pthread_mutex_lock(&mutex);   // 访问前上锁
num++;                        // 临界区代码
pthread_mutex_unlock(&mutex); // 访问后释放锁
// ...

pthread_mutex_destroy(&mutex); // 销毁锁
```

![image-20220121225308137](https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20220121225308137.png)



####  18.5 线程的销毁和多线程并发服务器端的实现

**销毁进程的方法**

- **pthread_join()**函数：阻塞等待进程销毁

  - **需要其它线程查询结束状态**

- **pthread_detach()**函数：非阻塞引导进程销毁

  - 使得子线程处于unjoinable状态（脱离态）
  - 当这一线程运行结束时，**它的资源会被系统自动回收**，
  - **不再需要在其它线程中对其进行 `pthread_join()` 操作**

  ![image-20220121231500832](https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20220121231500832.png)











## 计算机网络  - 自顶向下方法

> 20220602 ~ 20220622 [中科大郑烇、杨坚全套《计算机网络（自顶向下方法 第7版，James F.Kurose，Keith W.Ross）》课程_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1JV411t7ow?spm_id_from=333.999.0.0&vd_source=347ccd5e0d1f5374dbfbdd800d438163)

### 第1章 概论

#### 1.1 什么是Internet

**Internet -- 因特网**

- **由TCP/IP协议族支撑起的1种计算机网络**，通过网络连接设备将一堆网络连接在一起
- 前身为美国军方资助的**分组交换网络ARPANET**
- Internet是众多计算机网络中的1种，此外还有银行专用网络、军用网络等



**网络**

- 由**节点和边构成**的，与大小无关的拓扑
- 抽象的概念



**节点**

- **主机节点** -- 手机、web服务器等端设备，产生和接收数据
- **数据交换节点** -- 中继器、交换机、路由器、负载均衡设备，转发数据



**边** -- 在计算机网络中即通信链路

- **接入链路** -- 主机节点接入到计算机网络的链路
- **主干链路** -- 路由器之间的链路



**协议**

- 协议是**分布式的对等层实体在信息交换过程中遵守的规范集合**

- 规范包括语法、语义、时序



#### 1.2 网络边缘

**网络结构** -- 网络中存在3级结构

- edge(边缘) core(核心) access(接入)
- **edge通过access接入core**  

- 原系统和目标系统之间就像有一个**瞬间切换开关** -- core提供的服务 -- **switch**

<img src="https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20220616105935351.png" alt="image-20220616105935351" style="zoom:50%;" />



**网络边缘** 

即端设备



**客户端/服务器模式**

主从结构 -- 服务器主、客户端从

**peer2peer模式**

端对端模式 -- 迅雷



#### 1.3 网络核心

<img src="https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20220617011134416.png" alt="image-20220617011134416" style="zoom: 67%;" />



**网络核心**

- 指由**分组交换机和链路构成的网状网络**

- 分组交换机器包括

  - 路由器

  - 链路层交换机



**线路交换**方式

- **独享线路**，多用于电话网络

- 线路交换节点之间的带宽的分片方式

  - 频分 -- FDM

  - 时分 -- TDM

  - 波分 -- WDM



**分组(packet)交换**方式

- 存储转发，**共享线路**
- 分组交换下网络核心的**关键功能**
  - **路由** -- 决定packet采用的源到目标的路径，由**路由算法**计算得出
    - 控制平面功能
  - **转发** -- 将packet从路由器的输入链路转移到输出链路
    - 数据平面功能



#### 1.4 接入网络和物理媒体

**接入网络将端设备接入网络核心**



**modem** -- 调制解调器

- 一种家用网络设备，俗称猫，作为为modulate和demodulation

- cable modem -- 用于复用电话线、有限电视线（**同轴电缆**）提供网络带宽



**链路物理媒体**

- 同轴电缆 -- 有线电话线、有限电视线
- 双绞线 -- 网口线
- 光纤 -- 网络干线采用
- 地面微波 -- 电信塔
- 卫星微波



#### 1.5 Internet结构和ISP

**ISP**(Internet Service Providers 网络服务提供商)

- **端系统通过ISP接入到Internet**
- 移动ISP、联通ISP、高校ISP



**IPS具有层次结构** -- Global ISP、Region ISP、Local ISP

- **一级ISP**完成**国际覆盖，两两互连，带宽极高**，如UUNet，BBN
- 二级ISP 三级ISP...
- 最终通过**local ISP**将端设备接入Internet



#### 1.6 分组延时、丢失和吞吐量

**4种分组延时** -- 任意2节点之间的分组传递消耗的时间

- **排队延时** -- 吞吐量不足时发生排队等待，取决于拥塞程度
- **传输延时** -- L/R(packet长度/链路带宽)，ms级别
- 处理延时 -- 校验、计算等处理，μs级别
- 传播延迟 -- 卫星距离长，μs-几百ms级别



**tracert** 查看两端之间的**中间节点**以及**往返延时**

- 基于**ICMP报文实现**（网络层协议），每次发送3个报文，测量往返延时
- TTL从1递增，直至找到目标主机

```bash
$ tracert baidu.com	# 查看本机和baidu服务器之间的延时
```

![image-20220617230107661](https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20220617230107661.png)



#### 1.7 协议层次及服务模型

**服务service**

低层实体向上层实体提供的功能



**服务访问点SAP**

服务提供者提供服务的位置，**传输层的SAP为port**



**协议与服务的关系**⭐

- 本层协议基于下层服务实现
- 实现本层协议的目的是为上层提供更好的服务



**PDU** -- Protocol Data Unit **协议数据单元**

- 应用层 -- message，报文
- 传输层 -- **segment**，报文段
- 网络层 -- **packet**/datagram，分组/数据包
- 数据链路层 -- frame，帧（有头有尾）
- 物理层 -- bit，位



**Internet协议栈**

- 应用层 -- 网络应用，HTTP、FTP、DNS
- 传输层 -- 端进程之间的数据传输，TCP、UDP
- 网络层 -- **端到端**之间路由，IP、ICMP
- 链路层 -- **相邻网络节点之间**的数据传输，PPP、802.11WLAN、802.3Ethernet、ARP
- 物理层 -- 数模信号转化，在物理线路上传送bit



计算机网络中**一次数据传输过程**

- 主机节点为7层设备

- 数据交换节点只要2-3层，最高层为网络层
  - router3层
  - switch2层

<img src="https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20220618093710757.png" alt="image-20220618093710757" style="zoom: 80%;" />



### 第2章 应用层

#### 2.1 应用层协议原理

**应用类型**

<img src="https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20220618101807204.png" alt="image-20220618101807204" style="zoom: 67%;" />



**用户代理(正向代理)** -- 各种客户端软件

- HTTP用户代理 -- Edge浏览器
- FTP用户代理 -- FTP软件
- SMTP用户代理 -- Foxmail



**常见知名端口**

- 21 -- FTP
- 22 -- SSH

- 23 -- Telnet

- 53 -- DNS

- 80 -- Http



**Endpoint**

端节点，层间提供服务的位置



**Socket(套接字)**

- 应用层每次信息传输时，都需要指定IP+Port+Data给传输层

- 可用socket**对固定的信息进行标识**，不用每次重复传输，**减少层间信息量**

  - **TCP socket四元组** -- [本机IP:本机Port; 目标IP:目标端口]的本地标识
  - **UDP socket二元组** -- [本机IP:本机Port]的本地标识，**[目标IP:目标端口]可变**



**TCP和UDP均为明文传输**，提供的服务**不具备安全性**，安全性由应用层实现



#### 2.2 web & HTTP

**HTTP** -- 超文本传输协议

- 超文本即非线性文本，**文件之间有指向关系**
- 超文本包括图片、音频、视频



**cookie** 

- **给http打上状态补丁**

  - http1.0默认无状态

  - http1.1可选

![image-20220619172405421](https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20220619172405421.png)



**web缓存** -- **正向代理服务器**

- 浏览器访问Proxy server
- 由Proxy server 访问源服务器，并**缓存response**

![image-20220619172034147](https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20220619172034147.png)

proxy是特殊的主机节点，LAN中的其余主机节点**通过它间接访问Web服务器**

![image-20220619195952442](https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20220619195952442.png)

window下设置proxy

<img src="https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20220619173002706.png" alt="image-20220619173002706" style="zoom: 67%;" />



**proxy缓存一致性**

Http咋Request中加入**`If-modified-since`**字段，获取缓存有效性信息，**打上缓存过期bug补丁**



#### 2.3 FTP

FTP服务器监听21号端口，等待客户端连接



常用命令

```bash
USER username
PASS password
LIST
RETR filename
STOR filename
```



#### 2.4 Email & SMTP

**SMTP** -- 发送邮件协议

- SMTP要求只能发送Ascii码范围内的数据[0, 127)
- 打上**Base64编解码补丁**后可以传输任意类型数据
  - Base64原理 -- `3 x 8 = 4 x 6`
  - 将3字节可能超过127的明文，转化为4字节[0, 64)范围内的base64编码



POP3 -- 邮件拉取协议



#### 2.5 DNS

**域名服务器DNS**

- 位于**应用层**的基础设施，本质上属于端系统
- 为应用层应用**提供域名解析、域名重定向**等服务服务



**DNS实现**

- **分层树结构**，基于域的命名机制，避免冲突+提高可读性
  - 数百个顶级域名 -- `.com .org .edu .us .cn`
  - 下挂二、三级域名
  - **叶节点为主机节点域名**

- 分布式数据库完成IP地址转化
- **运行在UDP**之上的port=53的应用（**强事务性**）
- 身是网络核心功能，但以应用层协议实现（**在网络边缘处理复杂性**）



**根服务器与TLD 服务器**

- 根服务器相当于/，全球共13个，无缓存的域名查询，都要从根服务器开始，**向下递归查询**

- TLD -- Top-Level Domain，顶级域名服务器



**设备上网必备信息**，可手动配置或通过DHCP协议从DHCP服务器获取

- 本机IP
- 子网掩码
- DNS IP
- GateWay Ip

![image-20220619222556018](https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20220619222556018.png)



**DNS协议报文格式**

<img src="https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20220619223247907.png" alt="image-20220619223247907" style="zoom: 80%;" />





#### 2.7 CDN

**视频流量目前占据大部分互联网带宽**，总量80%以上，故称流媒体时代



**DASH** -- Dynamic Adaptive Streaming over HTTP **多媒体流化服务**

- **服务器将视频切割成8~10S的片段，以不同码率编码**，形成manifest file告示文件

- 客户端通过HTTP请求视频流片段，并**根据网络状态切换码率**，拉取manifest file对应资源



**集中式超级流媒体服务器存在的问题**

- 分布式客户端与中心服务器之间的跳数较多

- 重复流量多，浪费带宽

由此引出CDN



**CDN** -- Content Delivery Network **内容分发网络**，提供**流媒体加速服务**

- CDN有专门的运营商，分布式部署大量缓存节点，**缓存DASH片段**
- 终端用户向源服务器请求数据后，通过**域名解析重定向到最近的CDN**，以获取优质服务
- 本质是**让内容更靠近用户**



**ICP** -- Internet Content Provider **互联网内容供应商**（如ByteDance）

- 需要租用CDN运营商的CND服务器，并提前部署热门流媒体资源
- CDN的节点部署策略和ICP的内容缓存策略至关重要



### 第3章 传输层

#### 3.1 传输层服务

IP向传输层交付Best Effort服务，不保证可靠性

**TCP加强了IP的服务**，向上层**交付可靠的信息传递**（不重不漏）

**UDP依旧向上层交付尽力而为的服务**，只是用端口区分了进程



#### 3.2 多路复用和解复用

**多路复用** -- **IP层提供的服务**，发生在**从传输层到IP层**的过程中

- 不同传输层实体复用同一个IP层服务

- 源主机传输层从不同套接字中收集数据块，封装上传输层头部，交付给网络层



**多路分解** -- **传输层提供的服务**，发生在IP层到传输层的过程中

- 将主机到主机的数据，**区分为进程到进程的数据**

- 目标主机传输层将收到的报文的数据，将传输层头部解封装，**交付到正确的套接字**



**复用解复用过程中**

- TCP通过4元组**定位**socket，通过socket**获取**4元组

- UDP通过2元组定位socket，通过socke获取2元组



#### 3.3 无连接传输 UDP

**UDP适用对象**

- 流媒体应用 -- 实时性要求高，数据量大

- 事务型应用 -- DNS服务



**UDP报文格式**

- **`8B固定长度头部 = 2B源端口 + 2B目标端口 + 2B长度(含头部) + 2B校验和(EDC)`**

- EDC -- **差错控制编码**，检测范围包括头部 + 报文

<img src="https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20220620155230491.png" alt="image-20220620155230491" style="zoom: 80%;" />



#### 3.4 RDT原理

**RDT** -- Reliable Data Transport **可靠数据传输**

- 通常**由传输层TCP实现**

- 理论上也可以交由应用层自己实现

- 下层服务的不可靠性，决定了RDT实现的复杂性



##### RDT1.0 可靠信道上的可靠数据传输

本层只需封装+转发



##### RDT2.0 具有比特差错的信道

- 引入**checksum校验**

- **接收方需回复ACK确认**，发送方**停止等待ACK**（ACK本身也要EDC）

- **发送方需缓存数据，以备重传**

<img src="https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20220620181414554.png" alt="image-20220620181414554" style="zoom: 67%;" />



##### RDT2.1 修复ACK出错的bug

RDT2.0 不完备 -- 当ACK出错时，发送方无法处理（如果重发可能导致重复，如果不重发可能丢失数据）

- **引入序号**，发送方给数据编上序号P0、P1、P2...Pi...

- 当发送方收到错误ACK后，立即重传

- 接收方根据序号去重

<img src="https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20220620194257566.png" alt="image-20220620194257566" style="zoom:67%;" />



##### RDT3.0 具有比特差和分组丢失的信道

信道可能丢失packet，包括Pi和ACK

- **引入超时重传机制**，发送方在定时器超时而ACK未到时，重传packet
- 超时时间合理值 = 均值 + kσ
- RDT3.0是相对完美的协议，但1次只发1个分组，存在效率问题



##### 滑动窗口协议 sliding window⭐

**发送缓冲区** 

- 内存中的一块区域，用于存放已发送但未确认的packet

- 只有落在发送缓冲区之内分组允许被发送



**发送窗口**

- **发送缓冲区子集**，**存放当前已发送未经确认的packet**，

  - 发送新分组 -- 窗口前沿向前滑动

  - 收到ACK -- 窗口后沿向前滑动

  - 前沿 - 后沿 ≤ 发送缓冲区大小

<img src="https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20220620215607067.png" alt="image-20220620215607067" style="zoom:50%;" />



**接收窗口**

- 接收窗口控制哪些分组可以被接收

- 接收窗口尺寸Wr>1时，允许乱序接收

- **滑动方式**

  - 低序号分组到来，接收窗口移动

  - 高序号分组乱序到来，**缓存但不交付**（保证向上层有序交付），不滑动

- **发送确认**

  - Wr = 1 -- **累计确认**，对顺序到来的最高位分组进行确认，收到ack4意味着分组0-3必定已收到

  - Wr > 1 -- 非累积确认，收到ack4不意味着分组0-3必定已收到



**GBN协议与SR协议**

- 滑动窗口协议的特化对象
  - Sr>1 Wr=1 -- GBN协议
  - Sr>1 Wr>1 -- SR协议

![image-20220620225751948](https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20220620225751948.png)



##### RDT3.1 将停止等待协议升级为pipeline协议

基于滑动窗口协议实现



#### 3.5 面向连接的传输 TCP

**TCP报文格式** -- 首部长度可变，**通常为固定20B**

- **`20B头部 = 源端口2B + 目的端口号2B + 序号4B + 确认号4B + 标志位 + 确认窗口2B + 校验和2B + ...`**

- 序号和确认号均以字节为单位，本质是**对TCP字节流的编码**

  - ack = 10，标识已经收到0-9数据，希望对方发送10及以后的数据（**具有累计确认含义**）

  - seq = 18，表示当前报文**数据部分的首字节**在字节流中的offset=18

- **ACK标志位置1使能ack字段**，否则ack无效

- 与UDP不同，**TCP报文没有专门字段指明数据部分长度**
  - **`TCP Data的长度= IP总长度 - IP Header长度 - TCP Header长度`**
  - UDP  Len字段是冗余信息

<img src="https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20220620231459263.png" alt="image-20220620231459263" style="zoom: 40%;" />



**TCP如何保证RDT**⭐

- **校验和**

  - 检验传输过程是否出错

  - 承载于报文校验和字段2B，用EDC检验

- **累积确认**

  - 接收方确认已收到的字节流编号

  - 承载于报文ack字段4B

- **超时重传**

  - 用于重发丢失的报文段

  - 定时器超时未收到累积确认，触发重传

- **流量控制** -- **考虑对方感受**

  - **同步通信双方速率**，避免接收端应用层不取数据，而发送端持续发送数据

  - 采用捎带技术，**将接收方接收缓存区可用空间大小，发送给发送方**

  - 承载于报文接收窗口字段2B

- **拥塞控制** -- **考虑网络感受**
  - 根据网络拥堵状态，调整通信速率

- **连接管理**
  - 3握4挥



**TCP快重传**

在定时器到时之前，**发送方收到冗余的3个ACK，立即重传该ACK对应报文**

- 场景模拟 -- 发送方发送 10~14 15~19 20~24 25~29 四个报文段

- 15~19 20~24 25~29报文段先到达，接收方接收窗口乱序接收

- 由于累积确认机制，发送方会三次发送ack=10的确认报文

![image-20220621001809154](https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20220621001809154.png)





**捎带技术piggybacking**

AB双向通信，B在发送给A数据的过程中，**捎带**ACK信息及可用接收窗口信息



**TCP3次握手**⭐

**握手的目的**

- 同意建立连接 -- AB相互知道对方愿意建立连接

- 分配通信资源 -- 分配接收、发送缓冲区等资源

- **同步通信参数** -- 互相告知对方自己的初始Seq



**2次握手的缺陷**（为什么要3次握手）

- 握手请求超时重发，导致**服务器维护半连接**，浪费资源

- **把旧数据当成新数据接收**



**握手过程**

- 客户端经历3种状态 -- CLOSED → SYN-SENT → ESTABLISHED

- 服务端经历4种状态 -- CLOSED → LISTEN → SYN-RCVD → ESTABLISHED

- 第一次握手的SYN报文和第二次握手的SYN+ACK报文不含数据，但**消耗1个字节流序号**

<img src="https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/format,png.png" alt="三次握手" style="zoom: 75%;" />



**TCP4次挥手**⭐

**挥手目的**

- 关闭双向连接

- 放连接资源



**挥手过程**

- 主动方经历5种状态，初始状态为ESTABLISHED

  - 发送FIN后进入FIN-WAIT-1状态

  - 收到ACK后进入FIN-WAIT-2状态

  - 收到FIN并发送ACK后进入TIME-WAIT状态

  - 2MSL后，进入CLOSED状态

- 被动方经历4种状态，初始状态为ESTABLISHED

  - 收到FIN并发送ACK后进入CLOSE-WAIT状态

  - 发送FIN后进入LAST-ACK状态

  - 收到ACK后进入CLOSED状态

- 被动方可能因未收到第四次挥手的ACK而重传FIN，所以主动方要经历2MSL的TIME-WAIT状态
  - **MSL**  Max Segment Lifetime-- 最大报文生存时间，TCP segment在网络core中的寿命

<img src="https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/format,png-16558677703653.png" alt="四次挥手" style="zoom:75%;" />



#### 3.6 拥塞控制原理

网络通畅时，packet注入速度等于packet泵出速度

**网络拥塞(Congestion)**时，packet注入速度逐渐小于packet泵出速度，若不加控制，**会加速恶化直至死锁**



#### 3.7 TCP拥塞控制

TCP采用**端到端拥塞控制**，端系统感知拥塞并调整传输速度，**将网络的复杂性放在网络边缘处理**



**拥塞检测**

- 明显拥塞 -- 发生segment超时重传

- 轻微拥塞 -- 收到3次冗余确认



**控制策略** -- 通过调整CongWin(拥塞窗口) & Threshold(警戒值)实现

- **慢启动阶段** -- 连接建立时，CongWin以RTT(Round-Trip Time 往返延时)为单位，**指数级扩大**，直至达到Threshold

  - 初始拥塞窗口CongWin = 1MSS = 1460B

  - 慢启动阶段在整个传输过程中的时间占比极小

- **拥塞避免阶段** --  CongWin以RTT为单位，**线性增加**，直到检测到拥塞

- **快恢复动作** -- 收到3次冗余ACK，触发快重传，同时**CongWin减半**

- **超时重传时**，网络明显拥塞，重置CongWin=1MSS，回到慢启动阶段

![image-20220321161052219](https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20220321161052219.png)



**TCP的公平性** -- 瓶颈链路上的主机对，均分链路带宽



### 第4章 网络层 - 数据平面

#### 4.1 导论

**网络层的功能**

- **转发** -- 将packet从路由器输端口转发到输出端口

  - 本地功能(局部功能)

  - 数据平面功能

- **路由** -- 选择源主机到目标主机间的路径，全局功能

  - 全局功能

  - 控制平面功能



#### 4.2 路由器组成

**路由器** -- 实现数据平面和控制平面功能

- 控制平面计算路由表

- 数据平面匹配路由表，经过交换结构，将packet从输入缓冲区传送到输出缓冲区

- **路由器包含多个端口** -- 路由器有 ≥ 2个IP地址，**才能在不同的网络之间转发packet**

![image-20220622170022323](https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20220622170022323.png)



**端口缓冲区**

- 用于匹配局部瞬时速度差

- 缓冲区满后，**新到的packet可能会被丢弃**，所以IP层不可靠



#### 4.3 IP Internet Protocol

**IP报文格式** -- **20字节固定头部**

<img src="https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20220627102005862.png" alt="image-20220627102005862" style="zoom:80%;" />



**IP分片和重组**

**Fragmentation**

- Ethernet链路层MTU=1500，IP层需要**对超过MTU的packet进行分片**

- 分片会复制20B头部信息

 **Reassembly**

- **由目标主机完成**

- 根据IP报文中16bitID+flags+offset重组分片

<img src="https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20220627110850656.png" alt="image-20220627110850656" style="zoom:80%;" />



**子网 subnet**

**IP地址 = 网络号(高位bits) + 主机号(低位bits)**

- **网络号相同的节点**(主机/路由器)构成的网络的一部分叫做**子网**

- 子网内的各主机间**物理直达**，无需路由介入

- 互联网**以子网为单位计算路由** -- 包括路由信息的发布和路由信息的计算

  - 子网内的所有主机**聚集为路由中的1个表项**

  - 这种聚集可嵌套，以进一步收敛

<img src="https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20220627150238989.png" alt="image-20220627150238989" style="zoom: 80%;" />



**IPv4地址分类** -- ABCDE类

- A类 -- 以0开头，1B网络号 + 3B主机号

- B类 -- 以10开头，2B网络号 + 2B主机号

- C类 -- 以110开头，3B网络号 + 1B主机号

  - 日常使用的是C类IP地址

  - 范围从192.0.0.0到223.255.255.255

![image-20220717184713334](https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20220717184713334.png)





**mask子网掩码**

用于CIDR(无类域间路由)中**区分网络号/主机号**



**IP地址获取**

- 手动配置

- **DHCP动态获取** -- Dynamic Host Configuration Protocol

  - 运行DHCP客户端向DHCP服务器获取IP

  - DHCP承载于UDP上

<img src="https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20220627162736834.png" alt="image-20220627162736834" style="zoom:80%;" />



**路由表**

- **控制平面和数据平面通过路由表联系**

- **`目标IP & Mask = 路由表项202.38.73.0`**时，将packet转发至IPx

- IPx即通过路由匹配的得到的next hop地址




<img src="https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20220627154304077.png" alt="image-20220627154304077" style="zoom:80%;" />



**路由聚集**

- 聚集指将路由表中满足条件的同类子网，聚集为1个表项

  - 减少广域网中的路由表条目数

  - 减少**路由信息通告**的数量

  - 减少路由计算代价



**NAT 网络地址转换**

Network Address Translation -- **用于解决IPv4地址不足的问题**，**正向代理子网内部请求**

- 本地网络（内网）只有一个有效IP地址，由**NAT路由器持有**

- 内网包含的多台主机设备，对外共用一个外网IP

- 内网主机对内使用内网IP，如10.0.0.1，内网IP对外不可见

- NAT路由器**负责内外网IP地址转化**

<img src="https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20220627214348112.png" alt="image-20220627214348112" style="zoom:80%;" />



#### 4.4 通用转发和SDN

**传统互联网网络设备特点** -- **垂直继承**

- 硬件、操作系统、软件捆绑

- 导致行为僵化，难以升级



**SDN 软件定义网络**

Software Defined Network -- **逻辑上的集中控制平面**

- 将**数据平面和控制平面分离**（传统方法是在路由器上统一实现）

- 数据平面 -- 分组交换机，**按照流表动作**，可表现为多种网络设备
  - 分组交换机为分布式

- 控制平面 -- 控制器 + 网络应用，计算和下发流表给分组交换机
  - 远程、集中的控制中心



### 第5章 网络层 - 控制平面

#### 5.2 路由选择算法

**路由选择**

- 在网络拓扑中，通过路由算法找到**最优路径**，**生成路由表**

- 路由信息**以子网为单位**计算



**路由算法**

- 输入 -- 网络拓扑、边的代价、源主机地址

- 输出 -- 源主机到所有主机的最优路径，即**汇集树**



**全局路由算法** -- 路由器拥有**完整**网络信息

- LS算法 -- Link Stat 链路状态算法，核心是Dijkstra算法

- LS路由过程

  - 每个路由器将自己与相邻节点的代价封装为LS分组

  - 将该**LS分组泛洪**至全网

  - 使用**Dijkstra算法**计算最优路径，**生成路由表**

![image-20220630113253048](https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20220630113253048.png)



**局部路由算法** -- 路由器知道物理**相邻**路由器代价

- distance vector routing -- 距离矢量路由选择



#### 5.3 单一自治系统路由选择

**AS** -- Autonomous System单一自治系统，**可由多个子网组成**

- 将互联网分成1个个AS区域

- AS区域以唯一ASN标识



**内部网关协议** -- 基于LS实现的AS内部协议

- RIP -- 路由信息协议

- OSPF -- 开放式最短路径优先



#### 5.4 ISP之间的路由选择 - BGP

**BGP 边界网关协议**

 Border Gateway Protocol -- 用于AS之间的路由选择

- 分层路由体系

  - AS内部

  - AS之间



**网关与路由器**

网关即出口路由器，位于ISP接入/不同网络连接处

![image-20220630163357361](https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20220630163357361.png)



#### 5.5 SDN控制平面

由SDN控制器上的网络OS集中实现



### 第6章 链路层和局域网

#### 6.1 链路层服务

**LAN与WAN**

- 局域网为多点连接

- 广域网为点到点连接，如跨太平洋海底光缆
  - 由2条单工实现双工，以避免碰撞

- 局域网链路层复杂度远高于广域网



**链路层服务**

- 将数据包封装在frame中，加上帧头帧尾
  - frame头部为源MAC地址和目标MAC地址

- 在相邻node间完成RDT



**网卡(Adapter NIC)实现了链路层和物理层功能**，两层紧密捆绑

- IP层路由器负责子网到子网


- **子网内部节点之间的传输由链路层负责**



#### 6.2 差错检测和纠正

**物理层**

**IEEE 802.3以太网协议** -- 同轴电缆、双绞线、光纤出错率低，不需要差错控制

**IEEE 802.11WLAN无线网协议** --  出错率高，需要额外实现RDT



#### 6.3 多点访问协议

多点接入问题 -- 各个节点协调使用共享性介质



**接入访问控制方式**

- 信道划分 -- TDMA FDMA CDMA 时分 频分 码分

- 随机访问 -- 随机获取使用权

  - ALOHA

  - CSMA/CD -- IEEE802.3 Ethernet中使用

  - CSMA/AD -- IEEE802.11 WLAN中使用

  - 二进制指数退避

- 令牌环网 -- 发送方需抓住token才能发送消息，由IBM开发



#### 6.4 LANS

**ARP协议** -- 完成IP地址到MAC地址的转换

- MAC地址用于链路层转发

- MAC地址与网卡绑定

- FF-FF-FF-FF-FF-FF为广播MAC地址



**以太网 Ethernet**

- 主流LAN技术，98%市场占有率

- 廉价，常见带宽100MB 1G 10G

- 常用介质

  - 同轴电缆 -- 包含铜芯和外导体铜网，接入点刺破外导体，接入铜芯

  - 双绞线 -- 俗称网线

  - 光纤



**Ethernet帧格式**

<img src="https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20220701150301625.png" alt="image-20220701150301625" style="zoom: 80%;" />



**集线器 hub** -- *近似于用于公共接入的粗导线*

<img src="https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20220701151244117.png" alt="image-20220701151244117" style="zoom: 67%;" />

<img src="https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20220701152032489.png" alt="image-20220701152032489" style="zoom:50%;" />



**交换机 Switch** -- 多个端口间的瞬时切换开关

- 负责frame的存储转发

- 链路层设备



#### 6.6 数据中心网络

数据中心网络 -- 数十万台主机构成的局域网络

- 电子商务 -- Amazon Taobao

- 内容服务 -- YouTube Akamai Apple Tiktok

- 搜索引擎 -- Google Baidu Bing

关注高并发性能和负载均衡



### 第8章 网络安全

#### 8.1 网络安全定义

**Bob Alice Trudy模型**

- 网络安全经典抽象模型

- **Trudy坏事干尽**

  - 窃听

  - 插入

  - 伪装

  - 劫持 -- 建立通信后，接管会话，踢出其中一方



#### 8.2 加密原理

**对称加密**

对称密钥加密学 -- DES

对称密钥加密体系



**非对称加密**

RSA算法

![image-20220629003845452](https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20220629003845452.png)

<img src="https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20220629004956615.png" alt="image-20220629004956615" style="zoom: 80%;" />



#### 8.3 认证

**认证** -- Bob要认证Alice的身份

- 通过签名实现

- **签名指用私钥加密，等价于打上自身标志**



#### 8.4 报文完整性

- 可验证

- 不可伪造

- 不可抵赖



**实现方法** -- 报文后追加**数字签名部分**

报文摘要算法 -- MD5 SHA-1

![image-20220629012322851](https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20220629012322851.png)

#### 8.5 密钥分发和证书

**通信双方安全共享对称密钥**

通过双方共同信赖的KDC中介实现



**安全获取公共密钥**

通过认证中心CA实现 -- certification authority

**证书** -- **由CA机构签名过的实体与实体公钥的捆绑关系**

![image-20220717172055494](https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20220717172055494.png)





#### 8.6 各个层次的安全性

应用层安全性 -- 安全电子邮件

传输层安全性 -- SSL 安全套接字层

网络层安全性 -- IPsec

链路层安全性 -- IEEE 802.11



#### 8.7 防火墙

**防火墙** -- 一种**IP层网络安全设备**，位于内网和公网接口处，起隔离作用

- 基于IP报文头部信息进行block

- **block规则**由网络管理员配置



**DOS攻击**

Denial Of Service 拒绝服务攻击

- 攻击方发送大量连接请求，耗尽服务器资源

- 正常用户被拒绝服务

- 可用防火墙禁止行为异常的访问方



应用程序网关可以起防火墙作用





