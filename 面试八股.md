### C++面试突击 

#### 01 单例模式

**保证类的实例化对象只有1个，并且提供1个访问它的全局节点**

- 应用场景

  - 一个操作系统只有一个文件系统

  - 计算机可以同时连接多台打印机，但打印机程序只有一个（避免重复打印）

- 实现方式

  - **将构造函数声明为私有**，禁止外部调用

  - **通过类静态成员函数，提供外部访问接口**

- **懒汉模式**
  - 第一次用到时才实例化
  - **存在线程安全隐患**，可通过加锁避免（double check优化）

- **饿汉模式**
  - main函数开始之前实例化，即程序运行后必定存在一个实例化对象
  - 饿汉模式本身保证线程安全

```c++
// 懒汉模式
class Singleton {
private:
    Singleton() {}						// 私有构造函数
    Singleton(const Singleton& s) {}	// 私有拷贝构造函数
    static Singleton *instance;			// 类内申明对象指针（类静态成员变量）
public:
    static Singleton* getInstance() {	// 访问单例对象的接口
        if(instance == nullptr) {		// first check
            lock();						// 加锁保证多线程安全
            if(instance == nullptr) {	// double check
                instance = new Singleton();
            }
            unlock();
        }

        return instance;
    }
};

Singleton* Singleton::instance = nullptr;	// 类外定义

int main() {
    Singleton::getInstance();			// 第一次用到时单例对象才实例化
    
    return 0;
}
```

```c++
// 饿汉模式
class Singleton {
private:
    Singleton() {}						// 私有构造函数
    Singleton(const Singleton& s) {}	// 私有拷贝构造函数
    static Singleton instance;			// 类内声明唯一实例（类静态成员变量）
public:
    static Singleton& getinstance() {	// 全局访问接口 必须为引用返回
        return instance;
    }
};

Singleton Singleton::instance;			// 类外定义 main函数开始前完成实例化
```

