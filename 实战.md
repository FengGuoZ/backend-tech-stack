### TinyWebServer

#### 池化技术

池是资源的容器，**池化技术本质上是对资源的复用**

- 资源在服务初始化时创建，服务关闭时销毁
- 池化技术的优势
  - 避免重复申请、释放资源的操作，复用资源，**提高服务器效率**
  - 连接和释放操作可能带来安全隐患， **由池集中管理资源更加安全稳定**



#### sql_connection_pool数据库连接池

**数据库连接池暴露的功能**

```c++
class connection_pool
{
public:
	MYSQL *GetConnection();					// 获取一个数据库连接
	bool ReleaseConnection(MYSQL *conn);	// 释放连接
	int GetFreeConn();						// 空闲链接计数
	void DestroyPool();						// 销毁所有连接

	// 单例模式
	static connection_pool *GetInstance();	// 获取数据库连接池单例
	// ...
}
```



**数据库连接池工作过程**

1. sql连接池初始化，创建sql连接并加入连接池管理
2. 工作线程从sql连接池中获取一个sql连接
3. 工作线程操作sql
4. 工作线程归还sql连接，重复2~4步
5. sql连接池销毁，释放连接



**MySQL提供的C接口**

```c++
// 1) 创建MYSQL句柄
MYSQL *con = NULL;
mysql_init(con);	// 初始化MYSQL类型的con句柄

// 2) 连接到数据库，数据库分配连接资源
con = mysql_real_connect(con, url.c_str(), User.c_str(), PassWord.c_str(), DBName.c_str(), Port, NULL, 0);

// 3) 执行mysql语句，成功则返回0
// 案例一：执行插入语句
char *sql_insert = “INSERT INTO user(username, passwd) VALUES('123', '123')”;
int ret = mysql_query(con, sql_insert);	//           
// 案例二：执行查询语句
int ret = mysql_query(con, "SELECT username,passwd FROM user");

// 4) 获取当前连接最新的结果集
MYSQL_RES *result = mysql_store_result(con);

// 5) 读取结果集的一行(随着调用会自动后移)
while (MYSQL_ROW row = mysql_fetch_row(result)){
    ;
}

// 关闭数据库连接，销毁资源
mysql_close(con);
```



#### threadpool线程池

**线程池的本质是复用线程资源**，避免频繁创建、销毁线程，提高效率

**线程池三大组件：工作线程、任务队列、管理者线程**



**工作线程workers**

- 工作线程是任务队列的消费者，不断尝试从任务队列中取任务并执行
- 任务队列为空时，sem_wait()阻塞，等待生产者生产数据并notify()通知

**任务队列**

- 存储待处理任务，提供线程安全的push pop操作
- 解耦，放任务和执行任务是两回事
- 异步，放任务无需等待执行任务完成
- 削峰，瞬时任务量大时有缓冲

**管理者线程**

- 用于优化线程池效率

- 周期性检测任务队列中任务数量及工作线程繁忙程度
- 任务过多时，增加工作线程数量
- 工作线程空闲时，销毁部分工作线程

**注意事项**

- pthread_create创建类成员函数线程时，要求必须为静态成员函数



#### Reactor模式

一种主线程和工作线程的协作模式

- **主线程只负责监听fd**
  - fd上有事件发生时，**立即通知工作线程**
  - 除此以外不负责任何其它工作

- **工作线程负责处理具体业务**
  - 读/写数据
  - 接收新连接
  - 处理业务逻辑
- 主线程和工作线程之间**通过请求队列关联**

![image-20220926220555774](https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20220926220555774.png)



#### http处理流程

- **接收客户端请求**
  - 主线程创建http对象，接收请求并将所有数据读入对应buffer
  - 将该对象插入到任务队列
  - 工作线程从任务队列中取出1个任务进行处理
- **解析请求报文**
  - 工作线程取出任务后，调用process_read函数，通过主、从状态机解析请求报文
- **发送响应报文至客户端**
  - 解析完之后，跳转do_request函数生成响应报文
  - 通过process_write写入buffer
  - 返回给浏览器客户端端



#### 异步日志处理流程

**线程A在任意位置打日志** `LOG_INFO("INFO", msg);`

线程A将日志信息**压入日志队列** `m_log_queue->push(msg);`  之后线程A继续执其它任务

**日志线程L**循环读取日志队列信息，并**输出到文件**



**同步日志 vs 异步日志**

- 同步日志：日志写入函数与工作线程**串行执行**
  - **同步写日志的I/O过程阻塞工作线程，服务器的并发能力下降**
- 异步日志：将所写的日志内容先**缓存入阻塞队列**，写线程从阻塞队列中取出内容，写入日志
  - 内存中的**缓存速度 >> 硬盘I/O速度**
  - 需要**单独开1个写线程处理日志IO**





### ROV上位机研发软件

#### ROV应用层协议

**数据帧由HEADER + DATA组成**

![image-20220926225225698](https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20220926225225698.png)

- **HEADER固定24B**

![image-20220926225348182](https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20220926225348182.png)

- **DATA长度由HEADER中dlen字段指定**



#### 如何判断数据为完整一帧(解决粘包)

**使用缓存（循环数组实现）存储收到的数据**

- 将socket的数据**读入大缓存**
  - 大缓存将粘包数据重新拼合
- **当前有效数据范围为[tail, head)**
  - tail为可读数据的首地址
  - head为可写位置的首地址
- **`if (head-tail+SIZE) % size >= 24`**、
  - 取出24字节至帧头结构体header中，tail+=24
  - **否则说明帧头未接收完全**，直接进入下一次读socket循环
- 校验帧头、帧尾
- **从header中提取dlen数据**，尝试取出dlen长度数据，若此时head-tail<dlen，回到socket接收逻辑中

- 以上过程，如果校验失败，tail向后移动一位



#### 如何使用mutex和conditon

**程序采用多线程框架**

- 生产者线程负责接受网口数据
- 消费者线程负责解析数据
- 生产者线程和消费者线程间通过信息队列关联
- **mutex用于保护信息队列的线程安全**
- **condition用于避免死锁**
  - 如果消费者线程拿到锁后，发现队列为空，无法取出数据，又不释放锁，程序会发生死锁
  - 使用条件变量，**让消费者线程阻塞在条件变量上，交出互斥锁**，让生产者能够拿到锁生产数据
  - 生产者生产数据后通过notify或broadcast通知阻塞在条件变量上的消费者消费数据



**ROV项目的网速拥塞问题**

- **问题描述**：水下ROV上有声纳、水下相机等大流量设备，使用时发现无法流畅加载
  - 判断是网络传输速度不足
- TCP协议栈中**默认开启Naggle算法**，目的是避免产生过多的小数据包，导致网络过载
  - Naggle算法要求收到前一数据的ACK包后，才能再发送下一数据
  - 这样再等待ACK过程中，**输出缓存区积累的数据，可以一次性发送出去**，大大**减少数组包数量**
- 然而**根据项目数据传输的特点**，数据量大，不会产生小数据包，**应当屏蔽Naggle算法**
  - 因为水下ROV上有声纳、水下相机等大流量设备，所以数据传输量很大
  - 如果每1帧都等收到对端ACK应答后再发送，则降低了吞吐能力，应当屏蔽Naggle算法，**允许有数据就发送**
- **设置套接字属性为TCP_NODELAY**即可

![image-20220926230744394](https://figure-bed-zwd.oss-cn-hangzhou.aliyuncs.com/img_for_markdown/image-20220926230744394.png)

#### ROV项目中遇到的困难

- 制定应用层协议，满足不同传感器设备的需求
- 保证信息队列的线程安全，解决死锁问题







### 啦

#### 手撕算法注意事项

- 不仅考察算法+coding能力（硬实力），**还考察沟通交流能力（软实力）**
  - **一定不要**急着一上来就写代码
  - 先通过沟通明确：要解决的问题、输入、输出
  - **可以先沟通思路**，和面试官大致确认后，再coding
- 同时注意编程质量和可读性
  - 代码风格
  - 变量命名
  - 注释



#### AB实验原理

AB实验本质是**同质样本组的对照实验**

先建立两个同质的样本组，同质即样本与整体组成特性一致

对其中一个组做出某种改动，然后观测这个改动对核心指标是否有显著影响

AB实验中的**原假设是这项改动不会对核心指标有显著影响**

做完实验后，如果P值足够小，则推翻原假设，证明这项改动会对核心指标产生显著影。



测试来源于假设检验

p即假设条件成立的样本占总样本的比率，一般要求p<0.05，也即~假设的置信率高于95%



#### 自我介绍

面试官您好，我叫朱皖东，本科就读于浙江大学，毕业时以专业第5的综合成绩保研至本校，目前硕士研二在读，预计2023年6月毕业。

专业技能方面熟悉计算机网络分层模型，可靠数据传输原理，TCP/IP Http Https等协议

熟悉并发编程同步、IO复用、进程间通讯机制和常用bash指令

熟悉SQL语法，MySQL事务、索引、锁

Leetcode算法题400+，主用语言为C++

本次求职意向为贵公司后端研发工程师，请多多指教



#### 项目中遇到的挑战及解决思路

挑战是多种多样的

- 内生性的：知识面不足，无法解决开发中遇到的问题
  - 查学位论文（入门）、专著（系统了解）、top文献（优化创新）
- 外源性的：厂家加工不及时、误差、少件漏件
  - 多沟通交流，主动催进度
  - 保持平和心态



#### 项目中的最大收获



#### 如何应对项目成员冲突



#### 介绍一下你的缺点

我认为**自己做事计划性存在不足**，需要进一步学习改进

- 很多时候只是简单地做手头地事，没有提前规划好合理的项目执行流程
  - 比如说做线和密封并行执行，合理的做法是先做硅胶密封，在等待固化的过程中做线
  - 而我往往是，先看到做线，就把线做好，做完之后才想到密封，这样就多了等待时间
- 团队不专业，希望公司内部可以更加清晰合理地规划







#### coding心理博弈

- **做一个合格的演员**，即使面试题秒杀，也要装作苦思冥想，积极交流后，适时给出正确答案
  - 体现沟通能力
  - 避免出新题
- 即使答不出来，也不轻言放弃，积极思考，给出想法
  - **不踩轻言放弃的雷**





#### 提问环节

- 请问本项目组具体负责哪些业务？
- 请问项目组需要的技术栈有哪些？
- 请问项目组比较重视求职者哪些方面的能力？



#### 实习收获

**接触当下流行的技术框架**，指导自身学习方向

> Http框架Gin，魔改成Hertz
>
> RPC框架Thrift

**学习后端业务流程**

> 产品给出需求文档
>
> 开会评估并修订需求
>
> 排期
>
> 撰写技术文档
>
> Codign
>
> 测试 + 上线
>
> 收益评估

**学习从开发到上线的企业级流程规范**

> Git代码管理和Gitlab云托管
>
> BOE环境测试
>
> Code Review
>
> SCM镜像构建
>
> TCE上线docker集群













